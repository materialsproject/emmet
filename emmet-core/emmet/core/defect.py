""" Core definition for Defect property Document """
from __future__ import annotations

from datetime import datetime
from tokenize import group
from typing import ClassVar, Dict, Tuple, Mapping, List
from pydantic import BaseModel, Field
from pydantic import validator

from monty.json import MontyDecoder
from monty.tempfile import ScratchDir
from itertools import groupby

from pymatgen.core import Structure, Composition, Element
from pymatgen.analysis.defects.core import DefectEntry, Defect
from pymatgen.analysis.defects.defect_compatibility import DefectCompatibility
from pymatgen.analysis.defects.thermodynamics import DefectPhaseDiagram, BrouwerDiagram
from pymatgen.electronic_structure.dos import CompleteDos
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
from pymatgen.entries.computed_entries import CompositionEnergyAdjustment
from pymatgen.entries.compatibility import MaterialsProject2020Compatibility
from pymatgen.ext.matproj import MPRester

from emmet.core.structure import StructureMetadata
from emmet.core.mpid import MPID
from emmet.core.cp2k.task import TaskDocument
from emmet.core.cp2k.calc_types.enums import CalcType, TaskType, RunType
from emmet.core.cp2k.material import MaterialsDoc
from emmet.core.cp2k.calc_types.utils import run_type, task_type
from emmet.builders.cp2k.utils import matcher

from pymatgen.analysis.defects.corrections import FreysoldtCorrection2d
from pymatgen.io.vasp.outputs import VolumetricData

# TODO Update DefectDoc on defect entry level so you don't re-do uncessary corrections
class DefectDoc(StructureMetadata):
    """
    A document used to represent a single defect. e.g. a O vacancy with a -2 charge.

    This document can contain an arbitrary number of defect entries, originating from
    pairs (defect and bulk) of calculations. This document provides access to the "best"
    calculation of each run_type.
    """

    # TODO VASP MatDocs dont need this, but I get error requiring arbitrary type
    class Config:
        arbitrary_types_allowed = True

    property_name: ClassVar[str] = "defect"

    defect: Defect = Field(None, description="Pymatgen defect object for this defect doc")

    name: str = Field(None, description="Name of this defect as generated by the defect object")

    material_id: MPID = Field(None, description="Unique material ID for the bulk material")

    task_ids: List[int] = Field(
        None, description="All task ids used in creating this defect doc."
    )

    calc_types: Mapping[int, CalcType] = Field(  # type: ignore
        None,
        description="Calculation types for all the calculations that make up this material",
    )
    task_types: Mapping[int, TaskType] = Field(
        None,
        description="Task types for all the calculations that make up this material",
    )
    run_types: Mapping[int, RunType] = Field(
        None,
        description="Run types for all the calculations that make up this material",
    )

    tasks: Mapping[RunType, Tuple[TaskDocument, TaskDocument]] = Field(
        None, description="Task documents (defect task, bulk task) for the defect entry of RunType"
    )

    entries: Mapping[RunType, DefectEntry] = Field(
        None, description="Dictionary for tracking entries for CP2K calculations"
    )

    last_updated: datetime = Field(
        description="Timestamp for when this document was last updated",
        default_factory=datetime.utcnow,
    )

    created_at: datetime = Field(
        description="Timestamp for when this material document was first created",
        default_factory=datetime.utcnow,
    )

    metadata: Dict = Field(description="Metadata for this defect")

    # TODO How can monty serialization incorporate into pydantic? It seems like VASP MatDocs dont need this
    @validator("entries", pre=True)
    def decode(cls, entries):
        for e in entries:
            if isinstance(entries[e], dict):
                entries[e] = MontyDecoder().process_decoded({k: v for k, v in entries[e].items()})
        return entries

    def update(self, defect_task, bulk_task, dielectric, query='defect'):

        defect_task_doc = TaskDocument(**defect_task)
        bulk_task_doc = TaskDocument(**bulk_task)

        rt = defect_task_doc.run_type
        tt = defect_task_doc.task_type
        ct = defect_task_doc.calc_type

        # Metadata
        last_updated = max(dtsk.last_updated for dtsk, btsk in self.tasks.values()) if self.tasks else datetime.now()
        created_at = min(dtsk.last_updated for dtsk, btsk in self.tasks.values()) if self.tasks else datetime.now()

        if defect_task_doc.task_id in self.task_ids:
            return
        else:
            self.last_updated = last_updated
            self.created_at = created_at
            self.task_ids.append(defect_task_doc.task_id)
            #self['deprecated_tasks'].update(defect_task.task_id)

            def _run_type(x):
                return run_type(x[0]['input']['dft']).value

            def _compare(new, old):
                # TODO return kpoint density
                return new['nsites'] > old.nsites

            if defect_task_doc.run_type not in self.tasks or _compare(defect_task, self.tasks[rt][0]):
                self.run_types.update({defect_task_doc.task_id: rt})
                self.task_types.update({defect_task_doc.task_id: tt})
                self.calc_types.update({defect_task_doc.task_id: ct})
                entry = self.__class__.get_defect_entry_from_tasks(
                            defect_task=defect_task,
                            bulk_task=bulk_task,
                            dielectric=dielectric,
                            query=query
                        )
                self.entries[rt] = entry
                self.tasks[rt] = (defect_task_doc, bulk_task_doc)

    def update_all(self, tasks, query='defect'):
        for defect_task, bulk_task, dielectric in tasks:
            self.update(defect_task=defect_task, bulk_task=bulk_task, dielectric=dielectric, query=query)

    @classmethod
    def from_tasks(cls, tasks: List, query='defect', material_id=None) -> "DefectDoc":
        """
        The standard way to create this document.

        Args:
            tasks: A list of defect,bulk task pairs which will be used to construct a
                series of DefectEntry objects.
            query: How to retrieve the defect object stored in the task.
        """
        task_group = [TaskDocument(**defect_task) for defect_task, bulk_task, dielectric in tasks]

        # Metadata
        last_updated = datetime.now() or max(task.last_updated for task in task_group)
        created_at = datetime.now() or min(task.completed_at for task in task_group)
        task_ids = {task.task_id for task in task_group}

        deprecated_tasks = list(
            {task.task_id for task in task_group if not task.is_valid}
        )

        run_types = {task.task_id: task.run_type for task in task_group}
        task_types = {task.task_id: task.task_type for task in task_group}
        calc_types = {task.task_id: task.calc_type for task in task_group}

        def _run_type(x):
            return run_type(x[0]['input']['dft']).value

        def _task_type(x):
            return task_type(x[0]['input']['dft']).value

        def _sort(x):
            # TODO return kpoint density, currently just does supercell size
            return -x[0]['nsites'], x[0]['output']['energy']

        entries = {}
        final_tasks = {}
        metadata = {}
        for key, tasks_for_runtype in groupby(sorted(tasks, key=_run_type), key=_run_type):
            sorted_tasks = sorted(tasks_for_runtype, key=_sort)
            ents = [cls.get_defect_entry_from_tasks(t[0], t[1], t[2], query) for t in sorted_tasks]
            metadata[key] = {'convergence': [(sorted_tasks[i][0]['nsites'], ents[i].energy) for i in range(len(ents))]}

            best_defect_task, best_bulk_task, dielectric = sorted_tasks[0]
            best_entry = cls.get_defect_entry_from_tasks(best_defect_task, best_bulk_task, dielectric, query)
            best_defect_task, best_bulk_task = TaskDocument(**best_defect_task), TaskDocument(**best_bulk_task)
            entries[best_defect_task.run_type] = best_entry
            final_tasks[best_defect_task.run_type] = (best_defect_task, best_bulk_task)

        data = {
                'entries': entries,
                'run_types': run_types,
                'task_types': task_types,
                'calc_types': calc_types,
                'last_updated': last_updated,
                'created_at': created_at,
                'task_ids': task_ids,
                'deprecated_tasks': deprecated_tasks,
                'tasks': final_tasks,
                'material_id': material_id if material_id else best_entry.parameters['material_id'],
                'entry_ids': {rt: entries[rt].entry_id for rt in entries},
                'defect': best_entry.defect,
                'name': best_entry.defect.name,
                'metadata': metadata,
        }
        prim = SpacegroupAnalyzer(best_entry.defect.bulk_structure).get_primitive_standard_structure()
        data.update(StructureMetadata.from_structure(prim).dict())
        return cls(**data)

    @classmethod
    def get_defect_entry_from_tasks(cls, defect_task, bulk_task, dielectric=None, query='transformations.history.0.defect'):
        """
        Extract a defect entry from a single pair (defect and bulk) of tasks.

        Args:
            defect_task: task dict for the defect calculation
            bulk_task: task dict for the bulk calculation
            dielectric: Dielectric doc if the defect is charged. If not present, no dielectric
                corrections will be performed, even if the defect is charged.
            query: Mongo-style query to retrieve the defect object from the defect task
        """
        parameters = cls.get_parameters_from_tasks(defect_task=defect_task, bulk_task=bulk_task)
        if dielectric:
            parameters['dielectric'] = dielectric

        defect_entry = DefectEntry(
            cls.get_defect_from_task(query=query, task=defect_task),
            uncorrected_energy=parameters['defect_energy'] - parameters['bulk_energy'],
            parameters=parameters,
            entry_id=parameters['entry_id']
        )
        DefectCompatibility().process_entry(defect_entry, perform_corrections=True)
        defect_entry_as_dict = defect_entry.as_dict()
        defect_entry_as_dict['task_id'] = defect_entry_as_dict['entry_id']  # this seemed necessary for legacy db

        return defect_entry

    @classmethod
    def get_defect_from_task(cls, query, task):
        """
        Unpack a Mongo-style query and retrieve a defect object from a task.
        """
        defect = unpack(query.split('.'), task)
        needed_keys = ['@module', '@class', 'structure', 'defect_site', 'charge', 'site_name']
        return MontyDecoder().process_decoded({k: v for k, v in defect.items() if k in needed_keys})

    @classmethod
    def get_parameters_from_tasks(cls, defect_task, bulk_task):
        """
        Get parameters necessary to create a defect entry from defect and bulk task dicts

        Args:
            defect_task: task dict for the defect calculation
            bulk_task: task dict for the bulk calculation
        """

        def get_init(x):
            """
            Helper function. If transformations were applied, get the structure post defect
            transformation
            """
            if x.get('transformations', {}).get('history'):
                for i, y in enumerate(x['transformations']['history']):
                    if y['@class'] == 'DefectTransformation':
                        if len(x['transformations']['history']) == 1:
                            return Structure.from_dict(x['input']['structure'])
                        else:
                            return Structure.from_dict(x['transformations']['history'][i+1]['input_structure'])
                return Structure.from_dict(x['transformations']['history'][0]['input_structure'])
            return Structure.from_dict(x['input']['structure'])

        init_defect_structure = get_init(defect_task)
        init_bulk_structure = get_init(bulk_task)  # use init to avoid site_properties in matching

        final_defect_structure = Structure.from_dict(defect_task['output']['structure'])
        final_bulk_structure = Structure.from_dict(bulk_task['output']['structure'])

        dfi, site_matching_indices = matcher(
            init_bulk_structure, init_defect_structure,
            final_bulk_struc=final_bulk_structure, final_defect_struc=final_defect_structure
        )
        defect_frac_sc_coords = final_defect_structure[dfi].frac_coords

        parameters = {
            'defect_energy': defect_task['output']['energy'],
            'bulk_energy': bulk_task['output']['energy'],
            'initial_defect_structure': init_defect_structure,
            'final_defect_structure': final_defect_structure,
            'vbm': bulk_task['output']['vbm'],
            'cbm': bulk_task['output']['cbm'],
            'defect_frac_sc_coords': defect_frac_sc_coords,
            'entry_id': defect_task.get('task_id')
        }

        # TODO Should probably get these even if not needed for corrections
        if init_defect_structure.charge != 0:
            axis_grid = [[float(x) for x in _] for _ in bulk_task['output']['v_hartree_grid']] if bulk_task['output'].get('v_hartree_grid') else None
            bulk_planar_averages = [[float(x) for x in _] for _ in bulk_task['output']['v_hartree_planar']] if bulk_task['output'].get('v_hartree_planar') else None
            defect_planar_averages = [[float(x) for x in _] for _ in defect_task['output']['v_hartree_planar']] if defect_task['output'].get('v_hartree_planar') else None
            bulk_site_averages = [float(x) for x in bulk_task['output']['v_hartree_sites']] if bulk_task['output'].get('v_hartree_sites') else None
            defect_site_averages = [float(x) for x in defect_task['output']['v_hartree_sites']] if defect_task['output'].get('v_hartree_sites') else None

            parameters['axis_grid'] = axis_grid
            parameters['bulk_planar_averages'] = bulk_planar_averages
            parameters['defect_planar_averages'] = defect_planar_averages
            parameters['defect_frac_sc_coords'] = defect_frac_sc_coords
            parameters['site_matching_indices'] = site_matching_indices
            parameters['bulk_site_averages'] = bulk_site_averages
            parameters['defect_site_averages'] = defect_site_averages

        return parameters


# TODO Some of this should be done by DefectCompatibility,
# but it's not clear how to do that since 2d materials 
# are not tagged in any particular way to allow defect compatibility
# to decide which correction to apply
class DefectDoc2d(DefectDoc):
    """
    DefectDoc subclass for 2D defects
    """

    @classmethod
    def get_defect_entry_from_tasks(cls, defect_task, bulk_task, dielectric=None, query='transformations.history.0.defect'):
        """
        Get defect entry from defect and bulk tasks. 

        Args:
            defect_task: task dict for the defect calculation
            bulk_task: task dict for the bulk calculation
            dielectric: dielectric tensor for the defect calculation
            query: query string for defect entry
        """
        parameters = cls.get_parameters_from_tasks(defect_task=defect_task, bulk_task=bulk_task)
        if dielectric:
            eps_parallel = (dielectric[0][0] + dielectric[1][1]) / 2
            eps_perp = dielectric[2][2]
            parameters['dielectric'] = (eps_parallel - 1) / (1 - 1/eps_perp)

        defect_entry = DefectEntry(
            cls.get_defect_from_task(query=query, task=defect_task),
            uncorrected_energy=parameters.pop('defect_energy') - parameters.pop('bulk_energy'),
            parameters=parameters,
            entry_id=parameters.pop('entry_id')
        )

        DefectCompatibility().process_entry(defect_entry, perform_corrections=False)
        with ScratchDir('.'):
            fc = FreysoldtCorrection2d(
                    defect_entry.parameters.get('dielectric'), 
                    "LOCPOT.ref", "LOCPOT.def", encut=520, buffer=2
                ) 
            lref = VolumetricData(
                structure=Structure.from_dict(bulk_task['input']['structure']), 
                data={'total': MontyDecoder().process_decoded(bulk_task['v_hartree'])}
            )
            ldef = VolumetricData(
                structure=Structure.from_dict(defect_task['input']['structure']), 
                data={'total': MontyDecoder().process_decoded(defect_task['v_hartree'])}
            )
            lref.write_file("LOCPOT.ref")
            ldef.write_file("LOCPOT.def")
            ecorr = fc.get_correction(defect_entry)
            defect_entry.corrections.update(ecorr)
            defect_entry.parameters['freysoldt2d_meta'] = fc.metadata

        defect_entry_as_dict = defect_entry.as_dict()
        defect_entry_as_dict['task_id'] = defect_entry_as_dict['entry_id']  # this seemed necessary for legacy db

        return defect_entry
    
class DefectThermoDoc(BaseModel):

    class Config:
        arbitrary_types_allowed = True

    property_name: ClassVar[str] = "Defect Thermo"

    material_id: str = Field(None, description="Unique material ID for the host material")

    task_ids: Dict = Field(
        None, description="All task ids used in creating these phase diagrams"
    )

    #TODO not by run type... in principle shouldn't be this way, but DOS is almost always GGA
    bulk_dos: CompleteDos = Field(None, "Complete Density of States for the bulk Structure")

    defect_phase_diagrams: Mapping[RunType, DefectPhaseDiagram] = Field(
        None, description="Defect phase diagrams for each run type"
    )

    brouwer_diagrams: Mapping[RunType, BrouwerDiagram] = Field(
        None, description="Brouwer diagrams"
    )

    # TODO How can monty serialization incorporate into pydantic? It seems like VASP MatDocs dont need this
    @validator("brouwer_diagrams", pre=True)
    def decode(cls, brouwer_diagrams):
        for e in brouwer_diagrams:
            if isinstance(brouwer_diagrams[e], dict):
                brouwer_diagrams[e] = MontyDecoder().process_decoded(
                    {k: v for k, v in brouwer_diagrams[e].items()}
                )
        return brouwer_diagrams

    @classmethod
    def from_docs(cls, defects: List[DefectDoc], materials: List[MaterialsDoc], electronic_structure: CompleteDos) -> "DefectThermoDoc":

        DEFAULT_RT = RunType('GGA')  # TODO NEED A procedure for getting all GGA or GGA+U keys
        DEFAULT_RT_U = RunType('GGA+U')

        mpid = defects[0].material_id

        chempots = {
            m.structure.composition.elements[0]:
                {rt: m.entries[rt].energy_per_atom for rt in m.entries}
            for m in materials if m.structure.composition.is_element
        }

        defect_entries = {}
        defect_phase_diagram = {}
        vbms = {}
        band_gaps = {}
        brouwer_diagrams = {}
        task_ids = {}

        dos = CompleteDos.from_dict(electronic_structure)
        bg = dos.get_gap()

        for m in materials:
            for rt, ent in m.entries.items():
                __found_chempots__ = True

                # Chempot shift
                for el, amt in ent.composition.element_composition.items():
                    if Element(el) not in chempots:
                        __found_chempots__ = False
                        break
                    _rt = DEFAULT_RT if rt not in chempots[Element(el)] else rt
                    adj = CompositionEnergyAdjustment(-chempots[Element(el)][_rt],
                                                      n_atoms=amt,
                                                      name=f"Elemental shift {el} to formation energy space"
                                                      )
                    ent.energy_adjustments.append(adj)

                if not __found_chempots__:
                    continue

                # Other stuff
                band_gaps[rt] = bg
                ent.parameters['software'] = 'cp2k'
                ent.structure.remove_spin()
                ent.structure.remove_oxidation_states()
                MaterialsProject2020Compatibility().process_entry(ent)

        for d in defects:
            for rt, ent in d.entries.items():
                # Chempot shift
                __found_chempots__ = True
                comp = Composition(ent.defect.defect_composition, allow_negative=True) - \
                       ent.defect.bulk_structure.composition
                for el, amt in comp.items():
                    if Element(el) not in chempots:
                        __found_chempots__ = False
                        break
                    _rt = DEFAULT_RT if rt not in chempots[Element(el)] else rt
                    ent.corrections[f"Elemental shift {el} to formation energy space"] = -amt * chempots[Element(el)][_rt]

                if not __found_chempots__:
                    continue

                # Other stuff
                if rt not in defect_entries:
                    defect_entries[rt] = []
                if rt not in task_ids:
                    task_ids[rt] = set()
                defect_entries[rt].append(d.entries[rt])
                vbms[rt] = d.entries[rt].parameters['vbm']  # TODO Need to find best vbm
                task_ids[rt].update(d.task_ids)

        for run_type in defect_entries:
            # TODO MUST FILTER COMPATIBLE AT SOME POINT
            defect_phase_diagram[run_type] = DefectPhaseDiagram(
                entries=defect_entries[run_type],
                vbm=vbms[run_type],
                band_gap=band_gaps[run_type],
                filter_compatible=False
            )
            brouwer_diagrams[run_type] = BrouwerDiagram(
                defect_phase_diagram=defect_phase_diagram[run_type],
                bulk_dos=dos,
                entries=[
                    m.entries[run_type]
                    if run_type in m.entries else m.entries[DEFAULT_RT_U]
                    if DEFAULT_RT_U in m.entries else m.entries[DEFAULT_RT]
                    for m in materials
                ]
            )

        data = {
            'material_id': mpid,
            'task_ids': task_ids,
            'brouwer_diagrams': brouwer_diagrams,
        }

        return cls(**{k: v for k, v in data.items()})


def get_dos(mpid):
    with MPRester() as mp:
        return mp.get_dos_by_material_id(mpid)


def get_entries(chemsys):
    with MPRester() as mp:
        return mp.get_entries_in_chemsys(chemsys)


def unpack(query, d):
    if not query:
        return d
    if isinstance(d, List):
        return unpack(query[1:], d.__getitem__(int(query.pop(0))))
    return unpack(query[1:], d.__getitem__(query.pop(0)))
